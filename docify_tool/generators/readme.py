# # docify_tool/generators/readme.py
# from __future__ import annotations
# from pathlib import Path
# import importlib.resources as pkg_resources

# # If your templates are in a subpackage, import that package for resources.
# from docify_tool import templates  # noqa: F401  (needed for pkg_resources.files)

# def collect_docify_context(path, client, ignore_dirs, ignore_exts):
#     """
#     Use/extend existing Docify analysis to populate these keys.
#     Return a dict of pure strings (no markdown bullets in values unless intended).
#     """
#     # --- You should adapt this to your repo’s existing analysis code. ---
#     # Below are placeholders; wire them to actual values Docify already extracts.
#     return {
#         "PROJECT_TITLE": Path(path).name,
#         "DESCRIPTION": "Two to four sentence summary generated by Docify.",
#         "FEATURES_BULLETS": "- Feature A\n- Feature B\n- Feature C",
#         "WEB_ENDPOINTS": "- GET /health\n- POST /login\n",
#         "WEB_AUTH": "Bearer tokens via Authorization header.",
#         "WEB_FEATURES": "- Rate limiting\n- CORS\n",
#         "WEB_SETUP": "- Frontend: npm install && npm run dev\n- Backend: uvicorn app:app --reload\n",
#         "WEB_ENV_VARS": "- `DATABASE_URL`\n- `SECRET_KEY`",
#         "CONFIGURATION": "List of manual inputs, specs, and settings maintained by the team.",
#         "PERMISSIONS_EDITORS": "Alice, Bob",
#         "PERMISSIONS_VIEW_ONLY": "QA Team",
#         "TECHNOLOGIES_BULLETS": "- Python 3.11\n- FastAPI\n- PostgreSQL\n- Docker",
#     }

# def _load_default_template_text() -> str:
#     # Uses Python stdlib to load package data (no extra deps).
#     with pkg_resources.files("docify_tool").joinpath("templates/readme.default.md").open("r", encoding="utf-8") as f:
#         return f.read()

# def _fill_template(template_text: str, ctx: dict[str, str]) -> str:
#     out = template_text
#     for key, val in ctx.items():
#         out = out.replace(f"{{{{{key}}}}}", val or "")
#     return _trim_empty_sections(out)

# def _trim_empty_sections(md: str) -> str:
#     """
#     Optional: remove headings whose immediate body is empty.
#     We’ll do a simple heuristic: if a token left a header with only whitespace/newlines, drop that header block.
#     Keep it conservative to avoid deleting user text.
#     """
#     import re
#     # Remove any H2/H3 section that contains only whitespace or dashes after a newline.
#     pattern = r"(?ms)^## [^\n]+\n(?:\s*|\n)+(?=(?:## |\Z))"
#     return re.sub(pattern, "", md).strip()  # tweak if you want finer control

# def generate_readme(path, output=None, client=None, ignore_dirs=None, ignore_exts=None):
#     ctx = collect_docify_context(path, client, ignore_dirs or [], ignore_exts or [])
#     template_text = _load_default_template_text()
#     rendered = _fill_template(template_text, ctx)

#     out_path = Path(output) if output else Path(path) / "README.md"
#     out_path.write_text(rendered, encoding="utf-8")
